import json

def evaluate(response: str, parameters: dict) -> tuple[float, str]:
    expected_sentiments = parameters.get("expected_sentiments", [])
    # response_format is from test_classes.yaml, typically 'list_of_sentiments'
    
    if not expected_sentiments:
        return 0.0, "No 'expected_sentiments' provided in parameters."

    try:
        actual_sentiments = json.loads(response)
        if not isinstance(actual_sentiments, list):
            return 0.0, f"Response must be a JSON list. Got: {type(actual_sentiments)}"
    except json.JSONDecodeError:
        return 0.0, f"Invalid JSON in response: {response[:100]}..."
    except Exception as e:
        return 0.0, f"Error parsing response: {str(e)}"
    
    if len(actual_sentiments) != len(expected_sentiments):
        return 0.0, f"Expected {len(expected_sentiments)} sentiments, got {len(actual_sentiments)}."
    
    correct_count = 0
    details = []
    for i, (actual, expected) in enumerate(zip(actual_sentiments, expected_sentiments)):
        if str(actual).strip().lower() == str(expected).strip().lower():
            correct_count += 1
            details.append(f"Item {i+1}: Correct ('{expected}')")
        else:
            details.append(f"Item {i+1}: Incorrect. Expected: '{expected}', Got: '{actual}'")
            
    if not expected_sentiments: # Should be caught earlier, but defensive
        score = 0.0
    else:
        score = float(correct_count) / len(expected_sentiments)
        
    detail_str = f"Correctly identified {correct_count} out of {len(expected_sentiments)} sentiments. Details:\n" + "\n".join(details)
    return score, detail_str
