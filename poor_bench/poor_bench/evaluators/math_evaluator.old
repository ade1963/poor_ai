import json
from decimal import Decimal, InvalidOperation

def evaluate(response: str, parameters: dict) -> tuple[float, str]:
    expected = parameters.get("expected_answer")
    precision = parameters.get("precision", 2)  # Default precision if not specified
    # expected_format is from test_classes.yaml, not typically overridden per test instance for this evaluator
    # For this simple version, we assume JSON if 'answer' key is sought.

    try:
        # Attempt to parse as JSON first, as per common use case
        response_data = json.loads(response)
        if isinstance(response_data, dict):
            actual = response_data.get("answer")
            if actual is None:
                # Fallback: maybe the response IS the answer, not wrapped in JSON
                # This is a heuristic. A stricter evaluator might fail here.
                actual = response # Treat the whole response as the potential answer string
        elif isinstance(response_data, (int, float, str)):
            # If JSON parses to a direct number or string, use that.
            actual = response_data
        else:
            # Unrecognized JSON structure
            actual = response # Fallback to raw response
            
    except json.JSONDecodeError:
        # If not JSON, assume the raw response string is the answer
        actual = response
    except Exception:
        return 0.0, "Error processing response structure."

    if expected is None:
        return 0.0, "Missing 'expected_answer' in evaluation parameters."

    try:
        # Ensure expected and actual are strings before Decimal conversion for consistency
        expected_decimal = Decimal(str(expected))
        actual_decimal = Decimal(str(actual))
        
        # Quantize both to the same precision before comparison
        # Precision is number of decimal places, so '1e-2' for 2 places, '1e-0' for 0 places.
        quantizer = Decimal('1e-' + str(precision))
        
        if actual_decimal.quantize(quantizer) == expected_decimal.quantize(quantizer):
            return 1.0, f"Correct. Expected: {expected_decimal}, Got: {actual_decimal}"
        else:
            return 0.0, f"Incorrect. Expected: {expected_decimal}, Got: {actual_decimal}"
    except InvalidOperation:
        # Handle cases where conversion to Decimal fails (e.g., non-numeric strings)
        # Simple string comparison as a last resort if numbers are not interpretable
        if str(actual).strip() == str(expected).strip():
            return 1.0, f"Correct (non-numeric match). Expected: {expected}, Got: {actual}"
        return 0.0, f"Invalid numeric format or non-matching non-numeric. Expected: {expected}, Got: {actual}"
    except Exception as e:
        return 0.0, f"Error during numeric comparison: {str(e)}"
